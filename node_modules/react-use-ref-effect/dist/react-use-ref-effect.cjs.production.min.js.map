{"version":3,"sources":["../src/index.tsx"],"names":["noop","exports","useRefEffect","effect","dependencies","internalRef","useState","currentDeps","currentValue","cleanupPreviousEffect","setRefValue","newElement","dependencies_","cleanup_","effect_","ref_","Object","defineProperty","get","set","useEffect","current"],"mappings":"8EAQA,MAAMA,EAAgC,OAAAC,QAAAC,aAWV,CAC1BC,EACAC,KAAAA,MAGMC,EAAcC,EAAAA,UAAS,KAAA,IAGvBC,EAFAC,EAAe,KACfC,EAAwBT,EAKxBU,EAAeC,IAGfN,EAAYO,IAAkBL,GAC9BC,IAAiBG,IAEjBH,EAAeG,EACfJ,EAAcF,EAAYO,EAC1BP,EAAYQ,IACRF,IACFF,EAAwBJ,EAAYS,EAAQH,IAAeX,KAAAA,MAI1D,CAELa,EAAU,KACRJ,IACAA,EAAwBT,GAE1Be,EAAMC,OAAOC,eAAeP,EAAa,UAAW,CAClDQ,IAAK,IAAMV,EACXW,IAAKT,QASR,GAAA,OASHL,EAAYS,EAAUX,EAEtBiB,EAAAA,WACE,KAEEf,EAAYU,EAAKV,EAAYU,EAAKM,SAC3B,KACDhB,EAAYO,IAAkBR,GAChCC,EAAYQ,OAIjBR,EAAYO,EAAgBR,GAGxBC,EAAYU","sourcesContent":["import { useDebugValue, useEffect, useState } from 'react';\n\n// internalRef is used as a reference and therefore save to be used inside an effect\n/* eslint-disable react-hooks/exhaustive-deps */\n\n// the `process.env.NODE_ENV !== 'production'` condition is resolved by the build tool\n/* eslint-disable react-hooks/rules-of-hooks */\n\nconst noop: (...args: any[]) => any = () => {};\n\n/**\n * `useRefEffect` returns a mutable ref object to be connected with a DOM Node.\n *\n * The returned object will persist for the full lifetime of the component.\n * Accepts a function that contains imperative, possibly effectful code.\n *\n * @param effect Imperative function that can return a cleanup function\n * @param deps If present, effect will only activate if the ref or the values in the list change.\n */\nexport const useRefEffect = <T extends unknown>(\n  effect: (element: T) => void | (() => void),\n  dependencies?: any[]\n): React.RefCallback<T> & React.MutableRefObject<T | null> => {\n  // Use the initial state as mutable reference\n  const internalRef = useState(() => {\n    let currentValue = null as T | null;\n    let cleanupPreviousEffect = noop as () => void;\n    let currentDeps: any[] | undefined;\n    /**\n     * React.RefCallback\n     */\n    let setRefValue = (newElement: T | null) => {\n      // Only execute if dependencies or element changed:\n      if (\n        internalRef.dependencies_ !== currentDeps ||\n        currentValue !== newElement\n      ) {\n        currentValue = newElement;\n        currentDeps = internalRef.dependencies_;\n        internalRef.cleanup_();\n        if (newElement) {\n          cleanupPreviousEffect = internalRef.effect_(newElement) || noop;\n        }\n      }\n    };\n    return {\n      /** Execute the effects cleanup function */\n      cleanup_: () => {\n        cleanupPreviousEffect();\n        cleanupPreviousEffect = noop;\n      },\n      ref_: Object.defineProperty(setRefValue, 'current', {\n        get: () => currentValue,\n        set: setRefValue,\n      }),\n    } as {\n      cleanup_: () => void;\n      ref_: React.RefCallback<T> & React.MutableRefObject<T | null>;\n      // Those two properties will be set immediately after initialisation\n      effect_: typeof effect;\n      dependencies_: typeof dependencies;\n    };\n  })[0];\n\n  // Show the current ref value in development\n  // in react dev tools\n  if (process.env.NODE_ENV !== 'production') {\n    useDebugValue(internalRef.ref_.current);\n  }\n\n  // Keep a ref to the latest callback\n  internalRef.effect_ = effect;\n\n  useEffect(\n    () => {\n      // Run effect if dependencies change\n      internalRef.ref_(internalRef.ref_.current);\n      return () => {\n        if (internalRef.dependencies_ === dependencies) {\n          internalRef.cleanup_();\n        }\n      };\n    }, // Keep a ref to the latest dependencies\n    (internalRef.dependencies_ = dependencies)\n  );\n\n  return internalRef.ref_;\n};\n"]}